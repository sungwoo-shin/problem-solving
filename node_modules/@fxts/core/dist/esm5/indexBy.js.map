{"version":3,"file":"indexBy.js","sourceRoot":"","sources":["../../src/indexBy.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,sBAAsB,EAAE,MAAM,mBAAmB,CAAC;AAC3D,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC3E,OAAO,MAAM,MAAM,UAAU,CAAC;AA2F9B,SAAS,OAAO,CAId,CAA0C,EAC1C,QAAY;IALd,iBAgDC;IAtCC,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UACL,QAAW;YAEX,OAAO,OAAO,CAAC,CAAC,EAAE,QAAe,CAGhC,CAAC;QACJ,CAAC,CAAC;KACH;IAED,IAAM,GAAG,GAAG,EAAoC,CAAC;IACjD,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,MAAM,CACX,UAAC,KAAK,EAAE,CAAC;YACP,IAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACjB,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;gBAClB,MAAM,IAAI,sBAAsB,EAAE,CAAC;aACpC;YACD,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC;QACjC,CAAC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,MAAM,CACX,UAAO,KAAK,EAAE,CAAC;;;;4BACD,qBAAM,CAAC,CAAC,CAAC,CAAC,EAAA;;wBAAhB,GAAG,GAAG,SAAU;wBACtB,sBAAO,CAAA,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAA,EAAC;;;aAChC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,OAAO,CAAC","sourcesContent":["import { AsyncFunctionException } from \"./_internal/error\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\nimport reduce from \"./reduce\";\nimport type Cast from \"./types/Cast\";\nimport type Equals from \"./types/Equals\";\nimport type { GetKeyOf } from \"./types/GetKeyOf\";\nimport type IterableInfer from \"./types/IterableInfer\";\nimport type Key from \"./types/Key\";\nimport type ReturnValueType from \"./types/ReturnValueType\";\n\n/**\n * Given `f` that generates a key,\n * turns a list of objects into an object indexing the objects by the given key.\n * Note that if multiple objects generate the same value for the indexing key only the last value will be included in the generated object.\n *\n * @example\n * ```ts\n * const given = [\n *   { category: \"clothes\", desc: \"good\" },\n *   { category: \"pants\", desc: \"bad\" },\n *   { category: \"shoes\", desc: \"not bad\" },\n * ];\n *\n * indexBy(a => a.category, given);\n * // {\n * //   clothes: { category: \"clothes\", desc: \"good\" },\n * //   pants: { category: \"pants\", desc: \"bad\" },\n * //   shoes: { category: \"shoes\", desc: \"not bad\" },\n * // };\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-indexby-zpeok | Try It}\n */\n\nfunction indexBy<A extends Key>(\n  f: (a: A) => A,\n  iterable: Iterable<A>,\n): { [K in A]: K };\n\nfunction indexBy<A extends Key>(\n  f: (a: A) => A | Promise<A>,\n  iterable: AsyncIterable<A>,\n): Promise<{ [K in A]: K }>;\n\nfunction indexBy<A extends object, B extends Key & A[keyof A]>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): {\n  [K in B]: A & { [K2 in GetKeyOf<A, B>]: K };\n};\n\nfunction indexBy<A extends object, B extends Key & A[keyof A]>(\n  f: (a: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<{\n  [K in B]: A & { [K2 in GetKeyOf<A, B>]: K };\n}>;\n\nfunction indexBy<\n  I extends Iterable<unknown> | AsyncIterable<unknown>,\n  F extends (a: IterableInfer<I>) => any,\n>(\n  f: F,\n): (iterable: I) => ReturnValueType<\n  I,\n  Equals<Awaited<ReturnType<F>>, IterableInfer<I>> extends 1\n    ? {\n        [key1 in Awaited<ReturnType<F>>]: key1;\n      }\n    : {\n        [key1 in Awaited<ReturnType<F>>]: IterableInfer<I> & {\n          [key2 in GetKeyOf<Cast<IterableInfer<I>, object>, key1>]: key1;\n        };\n      }\n>;\n\nfunction indexBy<A, B extends Key>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): { [K in B]: A };\n\nfunction indexBy<A, B extends Key>(\n  f: (a: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<{ [K in B]: A }>;\n\nfunction indexBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n): (iterable: A) => ReturnValueType<A, { [K in B]: IterableInfer<A> }>;\n\nfunction indexBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n  iterable?: A,\n):\n  | { [K in B]: IterableInfer<A> }\n  | Promise<{ [K in B]: IterableInfer<A> }>\n  | ((iterable: A) => ReturnValueType<A, { [K in B]: IterableInfer<A> }>) {\n  if (iterable === undefined) {\n    return (\n      iterable: A,\n    ): ReturnValueType<A, { [K in B]: IterableInfer<A> }> => {\n      return indexBy(f, iterable as any) as ReturnValueType<\n        A,\n        { [K in B]: IterableInfer<A> }\n      >;\n    };\n  }\n\n  const obj = {} as { [K in B]: IterableInfer<A> };\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return reduce(\n      (group, a) => {\n        const key = f(a);\n        if (isPromise(key)) {\n          throw new AsyncFunctionException();\n        }\n        return (group[key] = a), group;\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return reduce(\n      async (group, a) => {\n        const key = await f(a);\n        return (group[key] = a), group;\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default indexBy;\n"]}