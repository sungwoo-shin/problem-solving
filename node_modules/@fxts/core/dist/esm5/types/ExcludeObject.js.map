{"version":3,"file":"ExcludeObject.js","sourceRoot":"","sources":["../../../src/types/ExcludeObject.ts"],"names":[],"mappings":"","sourcesContent":["import type Cast from \"./Cast\";\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never;\n\ntype LastOf<T> = UnionToIntersection<\n  T extends any ? () => T : never\n> extends () => infer R\n  ? R\n  : never;\n\ntype Push<T extends any[], V> = [...T, V];\n\nexport type TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>;\n// https://stackoverflow.com/questions/55127004/how-to-transform-union-type-to-tuple-type/55128956#55128956\n\ntype Not<T extends boolean> = T extends true ? false : true;\n\ntype Equals<A, B> = A extends B ? (B extends A ? true : false) : false;\n\ntype ExcludeEach<A extends object, B extends A> = {\n  [key in keyof A]: B[key] extends boolean\n    ? Equals<B[key], boolean> extends false\n      ? Not<Cast<B[key], boolean>>\n      : Exclude<A[key], B[key]>\n    : Exclude<A[key], B[key]>;\n};\n\ntype CompactKeys<T extends object> = Exclude<\n  {\n    [key in keyof T]: T[key] extends never ? never : key;\n  }[keyof T],\n  never\n>;\n\nexport type ExcludeObject<\n  A extends object,\n  B extends A,\n  C = ExcludeEach<A, B>,\n  D = {\n    [key in keyof A]: Cast<C, A>[key] extends never ? A[key] : Cast<C, A>[key];\n  },\n> = Equals<Exclude<A, B> | B, A> extends true\n  ? Exclude<A, B>\n  : TuplifyUnion<CompactKeys<Cast<C, object>>>[\"length\"] extends 1\n  ? D\n  : A;\n"]}