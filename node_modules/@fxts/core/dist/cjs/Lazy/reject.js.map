{"version":3,"file":"reject.js","sourceRoot":"","sources":["../../../src/Lazy/reject.ts"],"names":[],"mappings":";;;AAAA,4CAAiE;AACjE,uDAAyB;AACzB,2DAA6B;AAI7B,4DAA8B;AA8F9B,SAAS,MAAM,CAIb,CAA6B,EAC7B,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAO,MAAM,CAAC,CAAC,EAAE,QAAe,CAG/B,CAAC;QACJ,CAAC,CAAC;KACH;IAED,IAAI,IAAA,kBAAU,EAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,IAAA,gBAAM,EAAC,UAAC,CAAC,IAAK,OAAA,IAAA,eAAK,EAAC,CAAC,CAAC,CAAC,CAAC,EAAE,aAAG,CAAC,EAAhB,CAAgB,EAAE,QAAQ,CAAC,CAAC;KAClD;IAED,IAAI,IAAA,uBAAe,EAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,IAAA,gBAAM,EAAC,UAAC,CAAC,IAAK,OAAA,IAAA,eAAK,EAAC,CAAC,CAAC,CAAC,CAAC,EAAE,aAAG,CAAC,EAAhB,CAAgB,EAAE,QAAQ,CAAC,CAAC;KAClD;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,MAAM,CAAC","sourcesContent":["import { isAsyncIterable, isIterable } from \"../_internal/utils\";\nimport not from \"../not\";\nimport pipe1 from \"../pipe1\";\nimport { type ExcludeObject } from \"../types/ExcludeObject\";\nimport type IterableInfer from \"../types/IterableInfer\";\nimport type ReturnIterableIteratorType from \"../types/ReturnIterableIteratorType\";\nimport filter from \"./filter\";\n\n/**\n * The opposite of {@link https://fxts.dev/docs/filter | filter}\n * Iterable/AsyncIterable of all elements `f` returns falsy for\n *\n * @example\n * ```ts\n * const iter = reject((a)=> a % 2 === 0, [0, 1, 2, 3, 4, 5, 6]);\n * iter.next() // {done:false, value: 1}\n * iter.next() // {done:false, value: 3}\n * iter.next() // {done:false, value: 5}\n * iter.next() // {done:true, value: undefined}\n *\n * // with pipe\n * pipe(\n *  [0, 1, 2, 3, 4, 5, 6],\n *  reject(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 3, 5]\n *\n * await pipe(\n *  Promise.resolve([0, 1, 2, 3, 4, 5, 6]),\n *  reject(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 3, 5]\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *  Promise.resolve([0, 1, 2, 3, 4, 5, 6]),\n *  toAsync,\n *  reject(async a => a % 2 === 0),\n *  toArray,\n * ); // [1, 3, 5]\n *\n * // with toAsync\n * await pipe(\n *  [Promise.resolve(0), Promise.resolve(1), Promise.resolve(2),\n *   Promise.resolve(3), Promise.resolve(4), Promise.resolve(5), Promise.resolve(6)],\n *  toAsync,\n *  reject(a => a % 2 === 0),\n *  toArray,\n * ); // [1, 3, 5]\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-reject-vrc7d | Try It}\n *\n * see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync},\n * {@link https://fxts.dev/docs/toArray | toArray}\n */\n\nfunction reject<A, B extends A>(\n  f: (a: A) => a is B,\n  iterable: Iterable<A>,\n): IterableIterator<A extends object ? ExcludeObject<A, B> : Exclude<A, B>>;\n\nfunction reject<A, B extends A>(\n  f: (a: A) => a is B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<\n  A extends object ? ExcludeObject<A, B> : Exclude<A, B>\n>;\n\nfunction reject<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends IterableInfer<A>,\n  C extends B,\n  R = B extends object ? ExcludeObject<B, C> : Exclude<B, C>,\n>(\n  f: (a: IterableInfer<A>) => a is C,\n): (\n  iterable: A,\n) => A extends AsyncIterable<any>\n  ? AsyncIterableIterator<R>\n  : IterableIterator<R>;\n\nfunction reject<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): IterableIterator<A>;\n\nfunction reject<A, B = unknown>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): AsyncIterableIterator<A>;\n\nfunction reject<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n): (iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>;\n\nfunction reject<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B = unknown,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n):\n  | IterableIterator<IterableInfer<A>>\n  | AsyncIterableIterator<IterableInfer<A>>\n  | ((iterable: A) => ReturnIterableIteratorType<A, IterableInfer<A>>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnIterableIteratorType<A, IterableInfer<A>> => {\n      return reject(f, iterable as any) as ReturnIterableIteratorType<\n        A,\n        IterableInfer<A>\n      >;\n    };\n  }\n\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return filter((a) => pipe1(f(a), not), iterable);\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    return filter((a) => pipe1(f(a), not), iterable);\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default reject;\n"]}