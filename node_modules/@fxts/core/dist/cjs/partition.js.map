{"version":3,"file":"partition.js","sourceRoot":"","sources":["../../src/partition.ts"],"names":[],"mappings":";;;AAAA,2CAA2D;AAC3D,2CAA2E;AAC3E,8DAAgC;AA8EhC,SAAS,SAAS,CAIhB,CAA6B,EAC7B,QAAY;IALd,iBAsCC;IA5BC,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,UAAC,QAAW;YACjB,OAAO,SAAS,CAAC,CAAC,EAAE,QAAe,CAAsC,CAAC;QAC5E,CAAC,CAAC;KACH;IACD,IAAI,IAAA,kBAAU,EAAmB,QAAQ,CAAC,EAAE;QAC1C,IAAM,KAAK,GAAG,IAAA,iBAAO,EAAC,UAAC,CAAC;YACtB,IAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACjB,IAAI,IAAA,iBAAS,EAAC,GAAG,CAAC,EAAE;gBAClB,MAAM,IAAI,8BAAsB,EAAE,CAAC;aACpC;YACD,OAAO,UAAG,OAAO,CAAC,GAAG,CAAC,CAAE,CAAC;QAC3B,CAAC,EAAE,QAAQ,CAAC,CAAC;QACb,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,CAGhD,CAAC;KACH;IAED,IAAI,IAAA,uBAAe,EAAmB,QAAQ,CAAC,EAAE;QAC/C,IAAM,KAAK,GAAG,IAAA,iBAAO,EAAC,UAAO,CAAC;;;;oBAAQ,KAAA,OAAO,CAAA;oBAAC,qBAAM,CAAC,CAAC,CAAC,CAAC,EAAA;wBAArB,sBAAA,cAAG,kBAAQ,SAAU,EAAC,EAAE,EAAA;;iBAAA,EAAE,QAAQ,CAAC,CAAC;QACvE,OAAO,KAAK,CAAC,IAAI,CAAC,UAAC,KAAK,IAAK,OAAA;YAC3B,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE;YACnB,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE;SACrB,EAH4B,CAG5B,CAAsD,CAAC;KACzD;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,kBAAe,SAAS,CAAC","sourcesContent":["import { AsyncFunctionException } from \"./_internal/error\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\nimport groupBy from \"./groupBy\";\nimport { type ExcludeObject } from \"./types/ExcludeObject\";\nimport type IterableInfer from \"./types/IterableInfer\";\nimport type ReturnPartitionType from \"./types/ReturnPartitionType\";\n\n/**\n * Split Iterable/AsyncIterable into two arrays:\n * one with all elements which satisfies `f` and the other with all elements that does not.\n *\n * @example\n * ```ts\n * partition((a) => a % 2 === 0, [1, 2, 3, 4, 5]); // [[2, 4], [1, 3, 5]]\n *\n * // with pipe\n * pipe(\n *   [1, 2, 3, 4, 5],\n *   partition((a) => a % 2 === 0), // [[2, 4], [1, 3, 5]]\n * );\n *\n * await pipe(\n *   Promise.resolve([1, 2, 3, 4, 5]),\n *   partition((a) => a % 2 === 0), // [[2, 4], [1, 3, 5]]\n * );\n *\n * // if you want to use asynchronous callback\n * await pipe(\n *   Promise.resolve([1, 2, 3, 4, 5]),\n *   toAsync,\n *   partition(async (a) => a % 2 === 0), // [[2, 4], [1, 3, 5]]\n * );\n *\n * // with toAsync\n * await pipe(\n *   [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3), Promise.resolve(4), Promise.resolve(5)],\n *   toAsync,\n *   partition((a) => a % 2 === 0), // [[2, 4], [1, 3, 5]]\n * );\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-partition-7vns0 | Try It}\n *\n *  see {@link https://fxts.dev/docs/pipe | pipe}, {@link https://fxts.dev/docs/toAsync | toAsync}\n */\n\nfunction partition<\n  A,\n  L extends A,\n  R extends A = A extends object ? ExcludeObject<A, L> : Exclude<A, L>,\n>(f: (a: A) => a is L, iterable: Iterable<A>): [L[], R[]];\n\nfunction partition<\n  A,\n  L extends A,\n  R extends A = A extends object ? ExcludeObject<A, L> : Exclude<A, L>,\n>(f: (a: A) => a is L, iterable: AsyncIterable<A>): Promise<[L[], R[]]>;\n\nfunction partition<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends IterableInfer<A>,\n  L extends B,\n  R extends B = B extends object ? ExcludeObject<B, L> : Exclude<B, L>,\n>(\n  f: (a: IterableInfer<A>) => a is L,\n): (\n  iterable: A,\n) => A extends AsyncIterable<any> ? Promise<[L[], R[]]> : [L[], R[]];\n\nfunction partition<A, B>(f: (a: A) => B, iterable: Iterable<A>): [A[], A[]];\n\nfunction partition<A, B>(\n  f: (a: A) => B,\n  iterable: AsyncIterable<A>,\n): Promise<[A[], A[]]>;\n\nfunction partition<A extends Iterable<unknown> | AsyncIterable<unknown>, B>(\n  f: (a: IterableInfer<A>) => B,\n): (iterable: A) => ReturnPartitionType<A>;\n\nfunction partition<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends boolean,\n>(\n  f: (a: IterableInfer<A>) => B,\n  iterable?: A,\n):\n  | [IterableInfer<A>[], IterableInfer<A>[]]\n  | Promise<[IterableInfer<A>[], IterableInfer<A>[]]>\n  | ((iterable: A) => ReturnPartitionType<A>) {\n  if (iterable === undefined) {\n    return (iterable: A): ReturnPartitionType<A> => {\n      return partition(f, iterable as any) as unknown as ReturnPartitionType<A>;\n    };\n  }\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    const group = groupBy((a) => {\n      const key = f(a);\n      if (isPromise(key)) {\n        throw new AsyncFunctionException();\n      }\n      return `${Boolean(key)}`;\n    }, iterable);\n    return [group[\"true\"] || [], group[\"false\"] || []] as unknown as [\n      IterableInfer<A>[],\n      IterableInfer<A>[],\n    ];\n  }\n\n  if (isAsyncIterable<IterableInfer<A>>(iterable)) {\n    const group = groupBy(async (a) => `${Boolean(await f(a))}`, iterable);\n    return group.then((group) => [\n      group[\"true\"] || [],\n      group[\"false\"] || [],\n    ]) as Promise<[IterableInfer<A>[], IterableInfer<A>[]]>;\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default partition;\n"]}