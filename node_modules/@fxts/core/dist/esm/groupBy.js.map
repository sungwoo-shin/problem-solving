{"version":3,"file":"groupBy.js","sourceRoot":"","sources":["../../src/groupBy.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,sBAAsB,EAAE,MAAM,mBAAmB,CAAC;AAC3D,OAAO,EAAE,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAC3E,OAAO,MAAM,MAAM,UAAU,CAAC;AAqG9B,SAAS,OAAO,CAId,CAA0C,EAC1C,QAAY;IAKZ,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,CACL,QAAW,EAC2C,EAAE;YACxD,OAAO,OAAO,CAAC,CAAC,EAAE,QAAe,CAGhC,CAAC;QACJ,CAAC,CAAC;KACH;IAED,MAAM,GAAG,GAAG,EAAsC,CAAC;IACnD,IAAI,UAAU,CAAmB,QAAQ,CAAC,EAAE;QAC1C,OAAO,MAAM,CACX,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;YACX,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACjB,IAAI,SAAS,CAAC,GAAG,CAAC,EAAE;gBAClB,MAAM,IAAI,sBAAsB,EAAE,CAAC;aACpC;YACD,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;QAC1D,CAAC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,IAAI,eAAe,CAAmB,QAAQ,CAAC,EAAE;QAC/C,OAAO,MAAM,CACX,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE;YACjB,MAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACvB,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;QAC1D,CAAC,EACD,GAAG,EACH,QAAQ,CACT,CAAC;KACH;IAED,MAAM,IAAI,SAAS,CAAC,sDAAsD,CAAC,CAAC;AAC9E,CAAC;AAED,eAAe,OAAO,CAAC","sourcesContent":["import { AsyncFunctionException } from \"./_internal/error\";\nimport { isAsyncIterable, isIterable, isPromise } from \"./_internal/utils\";\nimport reduce from \"./reduce\";\nimport type Cast from \"./types/Cast\";\nimport type Equals from \"./types/Equals\";\nimport type { GetKeyOf } from \"./types/GetKeyOf\";\nimport type IterableInfer from \"./types/IterableInfer\";\nimport type iterableInfer from \"./types/IterableInfer\";\nimport type Key from \"./types/Key\";\nimport type ReturnValueType from \"./types/ReturnValueType\";\n\n/**\n * Splits Iterable/AsyncIterable into sets, grouped by the result of running each value through `f`.\n *\n * @example\n * ```ts\n * const given = [\n *   { category: \"clothes\", desc: \"good\" },\n *   { category: \"pants\", desc: \"bad\" },\n *   { category: \"shoes\", desc: \"not bad\" },\n *   { category: \"shoes\", desc: \"great\" },\n *   { category: \"pants\", desc: \"good\" },\n * ];\n *\n * groupBy((a) => a.category, given);\n * // {\n * //   clothes: [{ category: \"clothes\", desc: \"good\" }],\n * //   pants: [\n * //     { category: \"pants\", desc: \"bad\" },\n * //     { category: \"pants\", desc: \"good\" },\n * //   ],\n * //   shoes: [\n * //     { category: \"shoes\", desc: \"not bad\" },\n * //     { category: \"shoes\", desc: \"great\" },\n * //   ],\n * // };\n * ```\n *\n * {@link https://codesandbox.io/s/fxts-groupby-v8q3b | Try It}\n */\n\nfunction groupBy<A extends Key>(\n  f: (a: A) => A,\n  iterable: Iterable<A>,\n): { [K in A]: K[] };\n\nfunction groupBy<A extends Key>(\n  f: (a: A) => A | Promise<A>,\n  iterable: AsyncIterable<A>,\n): Promise<{ [K in A]: K[] }>;\n\nfunction groupBy<A extends object, B extends Key & A[keyof A]>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): {\n  [K in B]: (A & { [K2 in GetKeyOf<A, B>]: K })[];\n};\n\nfunction groupBy<A extends object, B extends Key & A[keyof A]>(\n  f: (a: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<{\n  [K in B]: (A & { [K2 in GetKeyOf<A, B>]: K })[];\n}>;\n\nfunction groupBy<\n  I extends Iterable<unknown> | AsyncIterable<unknown>,\n  F extends (a: IterableInfer<I>) => any,\n>(\n  f: F,\n): (iterable: I) => ReturnValueType<\n  I,\n  Equals<Awaited<ReturnType<F>>, IterableInfer<I>> extends 1\n    ? {\n        [key1 in Awaited<ReturnType<F>>]: key1[];\n      }\n    : {\n        [key1 in Awaited<ReturnType<F>>]: (IterableInfer<I> & {\n          [key2 in GetKeyOf<Cast<IterableInfer<I>, object>, key1>]: key1;\n        })[];\n      }\n>;\n\nfunction groupBy<A extends Key, B extends Iterable<A> | AsyncIterable<A>>(\n  f: (a: A) => A | Promise<A>,\n): (iterable: B) => ReturnValueType<B, { [K in A]: K[] }>;\nfunction groupBy<A, B extends Key>(\n  f: (a: A) => B,\n  iterable: Iterable<A>,\n): { [K in B]: A[] };\n\nfunction groupBy<A, B extends Key>(\n  f: (a: A) => B | Promise<B>,\n  iterable: AsyncIterable<A>,\n): Promise<{ [K in B]: A[] }>;\n\nfunction groupBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n): (iterable: A) => ReturnValueType<A, { [K in B]: IterableInfer<A>[] }>;\n\nfunction groupBy<\n  A extends Iterable<unknown> | AsyncIterable<unknown>,\n  B extends Key,\n>(\n  f: (a: IterableInfer<A>) => B | Promise<B>,\n  iterable?: A,\n):\n  | { [K in B]: IterableInfer<A>[] }\n  | Promise<{ [K in B]: IterableInfer<A>[] }>\n  | ((iterable: A) => ReturnValueType<A, { [K in B]: IterableInfer<A>[] }>) {\n  if (iterable === undefined) {\n    return (\n      iterable: A,\n    ): ReturnValueType<A, { [K in B]: IterableInfer<A>[] }> => {\n      return groupBy(f, iterable as any) as ReturnValueType<\n        A,\n        { [K in B]: IterableInfer<A>[] }\n      >;\n    };\n  }\n\n  const obj = {} as { [K in B]: IterableInfer<A>[] };\n  if (isIterable<IterableInfer<A>>(iterable)) {\n    return reduce(\n      (group, a) => {\n        const key = f(a);\n        if (isPromise(key)) {\n          throw new AsyncFunctionException();\n        }\n        return (group[key] || (group[key] = [])).push(a), group;\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  if (isAsyncIterable<iterableInfer<A>>(iterable)) {\n    return reduce(\n      async (group, a) => {\n        const key = await f(a);\n        return (group[key] || (group[key] = [])).push(a), group;\n      },\n      obj,\n      iterable,\n    );\n  }\n\n  throw new TypeError(\"'iterable' must be type of Iterable or AsyncIterable\");\n}\n\nexport default groupBy;\n"]}