{"version":3,"file":"memoize.js","sourceRoot":"","sources":["../../src/memoize.ts"],"names":[],"mappings":"AAkCA,SAAS,OAAO,CAGd,CAAI,EAAE,QAAY;IAClB,MAAM,QAAQ,GAAG,CAAC,GAAG,IAA0B,EAAiB,EAAE;QAChE,MAAM,GAAG,GAAG,OAAO,QAAQ,KAAK,UAAU,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACzE,MAAM,KAAK,GAAG,QAAe,CAAC;QAC9B,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS,EAAE;YAC7B,KAAK,CAAC,KAAK;gBACT,GAAG,IAAI,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,EAAE,CAAC;SACtE;QACD,MAAM,EAAE,KAAK,EAAE,GAAG,KAAK,CAAC;QACxB,IAAI,CAAC,CAAC,KAAK,YAAY,OAAO,IAAI,KAAK,YAAY,GAAG,CAAC,EAAE;YACvD,MAAM,IAAI,SAAS,CAAC,0CAA0C,CAAC,CAAC;SACjE;QAED,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YAClB,oEAAoE;YACpE,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;SACxB;QACD,MAAM,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;QAC1B,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QACvB,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC;IACF,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED,eAAe,OAAO,CAAC","sourcesContent":["/**\n * Creates a new function that, stores the results of its calculations in a {@link http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object | Map}.\n * When the function is called with same input again, it retrieves the cached result instead of recalculating it.\n * If resolver is provided, it determines the cache key for storing the result based on the arguments provided to the memoized function.\n * By default, the first argument provided to the memoized function is used as the map cache key\n *\n * @example\n * ```ts\n * const add10 = (a: number): number => a + 10;\n *\n * const memoized = memoize(add10);\n * console.log(memoized(5)); // 15\n * console.log(memoized(10)) // 20\n * console.log(memoized(5)); // 15 (cached)\n *\n * memoized.cache.clear(); // clear cache\n * console.log(memoized(5)); // 15 (no cache)\n * ```\n */\nfunction memoize<\n  F extends (...args: any[]) => any,\n  K extends Parameters<F>[0],\n  Return extends F & {\n    cache: K extends object ? WeakMap<K, ReturnType<F>> : Map<K, ReturnType<F>>;\n  },\n>(f: F): Return;\nfunction memoize<\n  F extends (...args: any[]) => any,\n  Resolver extends (...args: Parameters<F>) => any,\n  K extends ReturnType<Resolver>,\n  Return extends F & {\n    cache: K extends object ? WeakMap<K, ReturnType<F>> : Map<K, ReturnType<F>>;\n  },\n>(f: F, resolver: Resolver): Return;\nfunction memoize<\n  F extends (...args: any[]) => any,\n  R extends (...args: any[]) => any,\n>(f: F, resolver?: R) {\n  const memoized = (...args: Parameters<typeof f>): ReturnType<F> => {\n    const key = typeof resolver === \"function\" ? resolver(...args) : args[0];\n    const _self = memoized as any;\n    if (_self.cache === undefined) {\n      _self.cache =\n        key != null && typeof key === \"object\" ? new WeakMap() : new Map();\n    }\n    const { cache } = _self;\n    if (!(cache instanceof WeakMap || cache instanceof Map)) {\n      throw new TypeError(\"`cache` should only use `WeakMap`, `Map`\");\n    }\n\n    if (cache.has(key)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return cache.get(key)!;\n    }\n    const result = f(...args);\n    cache.set(key, result);\n    return result;\n  };\n  return memoized;\n}\n\nexport default memoize;\n"]}